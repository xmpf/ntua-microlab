; -----------------------------------------
; AUTHOR: MICHALIS PAPADOPOULLOS
; < github.com/xmpf >
; -----------------------------------------

; ----------------[INFO]-------------------
; DEFINE A 16-BYTE SPACE FOR EACH GROUP {UPPERCASE, LOWERCASE, NUMBERS}
; IN ORDER TO OPTIMIZE THE PROCESSING: O(n)
; -----------------------------------------

; ================[MACROS]=================

; PRINT SINGLE CHARACTER
PRINT MACRO CHAR
    PUSH DX
    PUSH AX
    MOV  DL,CHAR
    MOV  AH,02H
    INT  21H
    POP  AX
    POP  DX
ENDM

; OUTPUT STRING STORED AT <STRING> OFFSET
PRINT_STR MACRO STRING
    PUSH DX
    PUSH AX
    MOV  DX,OFFSET STRING
    MOV  AH,09H
    INT  21H
    POP  AX
    POP  DX
ENDM

; CLEAR REGISTER DATA
CLS_REG MACRO REG 
	MOV REG,0 
ENDM

; MACRO TO READ A CHARACTER INTO AL REGISTER 
READ MACRO
    MOV AH,08H
    INT 21H
ENDM

; LOAD MEM[MEMLOC] INTO `CX` REGISTER
MEMREAD MACRO MEMLOC
    MOV  CX,[MEMLOC]
ENDM

; SAVE VALUE OF `CX` REGISTER INTO MEM[MEMLOC]
MEMSAVE MACRO MEMLOC
    MOV [MEMLOC],CX
ENDM

EXIT MACRO
    MOV AH,4CH
    INT 21H
ENDM

VALID_CHAR MACRO
    PRINT AL
    INC BL              ; BL: GLOBAL CHARACTER COUNTER
    CMP BL,16           ; BL @ [0 .. 15]
    JGE  WAIT            ; IF > 15 => WAIT FOR `ENTER` OR `*`
ENDM

; ==========================================

; DATA SEGMENT:	DECLARATION OF OUR VARIABLES 
DATA_SEG SEGMENT 
    MSG 	DB 		0AH,0DH,'GIVE UP TO 16 CHARACTERS: $'

    INPUT 	DB 16 	DUP(0)
    UP_GRP 	DB 16 	DUP(0)
    LOW_GRP DB 16 	DUP(0)
    NUM_GRP DB 16 	DUP(?)

    UPPER_INDX DW   0000H
    LOWER_INDX DW   0000H
    NUM_INDX   DW   0000H

    NEW_LN	DB 		0AH,0DH, '$'
ENDS

; CODE SEGMENT: ALGORITHM IMPLEMENTATION
CODE_SEG SEGMENT
ASSUME CS:CODE_SEG, DS:DATA_SEG, SS:STACK

MAIN PROC FAR
    MOV AX,DATA_SEG 	; SET ACCUMULATOR TO POINT INTO DATA_SEG
    MOV DS,AX 			; COPY TO DS REGISTER (INIT)

ENTRY:
    PRINT_STR MSG 		; PRINT MESSAGE FOR INPUT

   	; SET REGISTERS TO ZERO
    CLS_REG BX          ; GLOBAL CHAR COUNTER
    CLS_REG CX          ; SPECIAL CHAR COUNTER
    CLS_REG DX


; GET INPUT FROM USER
CONTINUE:
	LEA DI,INPUT 		; POINTER TO INPUT VARIABLE 

READ_NEXT:
	READ
	CMP AL,0DH      	; ENTER PRESSED ? 
	JE  RESULT 			; IF YES SHOW RESULT
	
	CMP AL,'*' 			; IS * ?
	JE 	TERMINATE 		; IF YES TERMINATE

    CMP AL,20H      	; IS WHITESPACE
    JE  READ_NEXT      	; SKIP - READ NEXT CHARACTER

	CMP AL,'0' 			;
	JL  READ_NEXT 		; SKIP - READ NEXT CHARACTER
	CMP AL,'9'			; 
	JLE	SAVE_NUM 		;

	CMP AL,'A' 			;
	JL  READ_NEXT 		; SKIP - READ NEXT CHARACTER
	CMP AL,'Z'			; 
	JLE	SAVE_UPPER 		;
	
	CMP AL,'a' 			; 
	JL  READ_NEXT 		; SKIP - READ NEXT CHARACTER
	CMP AL,'z'			; 
	JLE	SAVE_LOWER 		;
	JG  READ_NEXT 		; SKIP - READ NEXT CHARACTER

; VALID CHARACTER => INCREMENT COUNTER
VALID_CHARACTER:
    INC BX              ; BL: GLOBAL CHARACTER COUNTER
    CMP BX,10H          ; BL @ [0 .. 15]
    JG  WAIT            ; IF > 15 => WAIT FOR `ENTER` OR `*`

; SAME FUNCTIONALITY - JUST SAVE CHARACTER INTO `INPUT` VARIABLE
; AND INCREMENT POINTER INDEX

; UPPERCASE INDEX POINTER SAVED INTO MEM[0x900]
SAVE_UPPER:
    VALID_CHAR
    MEMREAD UPPER_INDX	; LOAD UPPERCASE INDEX POINTER INTO CL
    LEA DI,UP_GRP       ; POINTER INTO UPPERCASE GROUP
    ADD DI,CX           ; COMPUTE EFFECTIVE ADDRESS
	MOV [DI],AL 		; SAVE UPPERCASE CHARACTER
	INC DI              ; INCREMENT INDEX POINTER
    INC CL              ; INCREMENT COUNTER 
	MEMSAVE UPPER_INDX 	; SAVE INDEX POINTER INTO MEM[UPPER_INDX]
    JMP READ_NEXT

; LOWERCASE INDEX POINTER SAVED INTO MEM[0x901]
SAVE_LOWER:
    VALID_CHAR
	MEMREAD LOWER_INDX 	; LOAD LOWERCASE INDEX POINTER INTO CL
    LEA DI,LOW_GRP
    ADD DI,CX           ; COMPUTE EFFECTIVE ADDRESS
	MOV [DI],AL
	INC DI              ; INCREMENT INDEX POINTER
    INC CL              ; INCREMENT COUNTER 
	MEMSAVE LOWER_INDX 	; SAVE LOWERCASE INDEX POINTER INTO MEM[LOWER_INDX]
    JMP READ_NEXT

; HERE WE CHECK FOR (MIN1,MIN2)
; NUMBERS INDEX POINTER SAVED INTO MEM[0x902]
SAVE_NUM:
    ; NOT YET IMPLEMENTED
    VALID_CHAR
    MEMREAD NUM_INDX
    LEA DI,NUM_GRP
    ADD DI,CX           ; COMPUTE EFFECTIVE ADDRESS
    MOV [DI],AL
    INC DI              ; INCREMENT INDEX POINTER
    INC CL              ; INCREMENT COUNTER 
    MEMSAVE NUM_INDX
    JMP READ_NEXT


; IF COUNTER > 16
; WAIT USER TO PRESS `ENTER` OR `*`
WAIT:
    READ
    ; IF `*` QUIT
    CMP AL,'*'
    JE  TERMINATE
    ; IF `ENTER` SHOW RESULT
    CMP AL,0DH
    JE  RESULT
    ; IF CHARACTER NOT RECOGNIZED JUMP TO WAIT
    JMP WAIT

RESULT:
    CMP BL,0
    JE  ENTRY
    PRINT_STR NEW_LN

; SHOW GROUP UPPERCASE
UPPERCASE_GRP:
    MEMREAD UPPER_INDX  ; LOAD UPPERCASE COUNTER INTO `CL`
    LEA DI,UP_GRP       ; POINT TO UPPERCASE GROUP
UPPERCASE_REP:
    PRINT [DI]          ; SHOW CHARACTER
    INC DI              ; INCREMENT INDEX POINTER
    DEC CL              ; COUNTER--
    CMP CL,0
    JGE UPPERCASE_REP    ; LOOP UNTIL ALL UPPERCASE CHARACTERS PRINTED
    PRINT '-'           

; SHOW GROUP LOWERCASE
LOWERCASE_GRP:
    MEMREAD LOWER_INDX  ; LOAD LOWERCASE COUNTER INTO `CL`
    LEA DI,LOW_GRP      ; POINT TO LOWERCASE GROUP
 LOWERCASE_REP:
    PRINT [DI]          ; SHOW CHARACTER 
    INC DI              ; INCREMENT INDEX POINTER
    DEC CL              ; COUNTER--
    CMP CL,0
    JGE LOWERCASE_REP    ; LOOP UNTIL ALL LOWERCASE CHARACTERS PRINTED
    PRINT '-'

; SHOW GROUP NUMBERS
NUMBERS_GRP:
    MEMREAD NUM_INDX    ; LOAD NUMBERS COUNTER INTO `CL` 
    LEA DI,NUM_GRP      ; POINT TO NUMBERS GROUP
NUMBERS_REP:
    PRINT [DI]          ; SHOW
    

    INC DI              ; INCREMENT INDEX POINTER
    DEC CL
    CMP CL,0              ; COUNTER--
    JGE NUMBERS_REP      ; LOOP UNTIL ALL NUMBERS PRINTED

TERMINATE:
    EXIT

MAIN ENDP

CODE_SEG ENDS
END MAIN