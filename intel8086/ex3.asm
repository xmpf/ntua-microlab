PRINT_STR MACRO STRING
	PUSH DX
	PUSH AX
	LEA  DX,STRING
	MOV  AH,09H
	INT  21H
	POP  AX
	POP  DX
ENDM

EXIT MACRO
	MOV AH,4CH
	INT 21H
ENDM

PRINT MACRO CHAR
	PUSH DX
	PUSH AX
	MOV  DL,CHAR
	MOV  AH,02H
	INT  21H
	POP  AX
	POP  DX
ENDM

READ MACRO
	MOV AH,08H
	INT 21H
ENDM

DATA SEGMENT
	MSG DB 0AH,0DH,'GIVE UP TO 16 CHARACTERS: $'
	INPUT DB 16 DUP(?)
	NEW_LINE DB 0AH,0DH, '$'
ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA,SS:STACK

MAIN PROC FAR
	MOV AX,DATA
	MOV DS,AX

ENTRY:
	PRINT_STR MSG
    MOV CX,10H      ; CX=16

INIT:               ; INITIALIZATION
	LEA DI,INPUT 	; DI POINTS TO INPUT
	ADD DI,CX 		; DI POINTS TO INPUT+16
	DEC DI 			; DI POINTS TO INPUT+15 (LAST MEM LOCATION)
	MOV AL,00H
	MOV [DI],AL 	; [DI] = 0
	LOOP INIT 		; [INPUT .. INPUT+15] = 0

CONTINUE:
	MOV CX,0 
	MOV BX,0
	MOV DX,0
	LEA DI,INPUT 	; DI POINTS TO INPUT

READ_NEXT:
	READ 			; READ ASCII CHAR INTO AL REGISTER
	CMP AL,0DH      ; ENTER PRESSED ? 
	JE RESULT 		; IF YES THEN SHOW RESULT
	
	CMP AL,'*'      ; IF * TERMINATE
	JE QUIT 
	
	CMP AL,20H      ; WHITESPACE
	JE SAVE 		
	
	CMP AL,'0'      ; IF LESS THAN 0 (ASCII)
	JL READ_NEXT 	; READ AGAIN
	CMP AL,39H 		; IF LESS THAN OR EQUAL TO '9'
	JLE SAVE_DIG 	; AL BETWEEN [30H .. 39H] (DIGITS)
	
	CMP AL,'A'      ; UPPERCASE
	JL READ_NEXT 	; IF LESS THAN 41H READ AGAIN
	CMP AL,'Z' 		; IF LESS THAN OR EQUAL TO 5AH 
	JLE SAVE 		; SAVE UPPERCASE

	CMP AL,'a'      ; LOWERCASE
	JL READ_NEXT 	; IF < 61H READ AGAIN
	CMP AL,'z' 		; IF > 7AH READ AGAIN
	JG READ_NEXT  

SAVE:	     		; SAVE CHARACTERS
	PRINT AL
	MOV [DI],AL
	INC DI 			; MEMORY LOCATION INDEX
	INC BL     		; COUNTER
	CMP BL,16 		
	JL READ_NEXT
	JMP WAIT1 		; IF >= 16 CHARS GIVEN WAIT FOR ENTER OR *

SAVE_DIG:     		; SAVE DIGITS
	PRINT AL
	MOV [DI],AL
	INC DI
	CMP BH,0  		; MIN1
	JE MIN1
	CMP BH,1 		; MIN2
	JE MIN2
	JMP FIGE

MIN1:         
	MOV CH,AL 		; STORE MIN1 IN CH
	
MIN2:
	MOV CL,AL  		; STORE MIN2 IN CL
	PUSH CX 		; SAVE (MIN1,MIN2) IN STACK

FIGE:
	INC BL    ;metritis xaraktiron(koinos)
	INC BH 
	CMP BL,16   	; COUNTER < 16
	JL READ_NEXT 	; CONTINUE READING
	
	
WAIT1:       	; READ 16 CHARACTERS NO MORE SPACE
	READ 		; READ ASCII CHAR INTO AL REGISTER
	CMP AL,0DH 	; ENTER RECEIVED
	JE RESULT

	CMP AL,'*' 	; TERMINATION SIGNAL
	JE QUIT
	
	JMP WAIT1
	
RESULT:
    CMP BL,0
    JE  ENTRY
	PRINT_STR NEW_LINE 
	LEA DI,INPUT 	; POINT TO [INPUT]
	PUSH BX      	; SAVE TO STACK

UPPERCASE:			; BH:BL HOLDS NUMBER OF UPPERCASE LETTERS
    CMP BL,0 		; WHILE BL != 0 REPEAT
    JE  GROUP1 		; IF BL == 0 NEXT GROUP
    DEC BL 			; DECREMENT
	MOV DL,[DI] 	; LOAD MEMORY
	INC DI 			; NEXT MEMORY LOCATION
	
	CMP DL,'A' 		; WHILE DL NOT IN [0x65 .. 0x5A] 
	JL UPPERCASE 	; NEXT UPPERCASE
	CMP DL,'Z'
	JG UPPERCASE 	; NEXT UPPERCASE

VALID_UPPERCASE:
	PRINT DL 		
	JMP UPPERCASE 	; NEXT UPPERCASE
	
GROUP1:				; GROUP UPPERCASE HAS NO MORE MEMBERS
	POP BX 			
	PRINT '-' 		; NEXT GROUP: LOWERCASE
	LEA DI,INPUT
	
	PUSH BX
LOWERCASE:    		; PROCESS GROUP LOWERCASE
    CMP BL,0 
    JE GROUP2 		; GROUP LOWERCASE HAS NO MORE MEMBERS
    DEC BL 			; COUNTER--
	MOV DL,[DI]
	INC DI 			; NEXT MEMORY LOCATION
	
	CMP DL,'a' 		; IF [MEM] NOT IN [0x61 .. 0x7a]
	JL LOWERCASE 	; CHECK NEXT
	CMP DL,'z'
	JG LOWERCASE 	; CHECK NEXT IF LOWERCASE

VALID_LOWERCASE:
	PRINT DL 		; VALID LOWERCASE PRINT IT
	JMP LOWERCASE 	; PROCESS NEXT LOWERCASE

GROUP2:				; GROUP:LOWERCASE HAS NO MORE MEMBERS
	POP BX
	PRINT '-'

	LEA DI,INPUT 	; POINT TO START OF INPUT MEMORY LOCATION
	POP CX
	MOV BH,0

NUM:           		; GROUP:NUMBERS
    CMP BL,0 		
    JE TELOS 		; NOTHING TO PROCESS => EXIT
    DEC BL			; COUNTER--
	MOV DL,[DI] 	; LOAD MEMORY LOCATION
	INC DI 			; MEMORY INDEX ++
	
	CMP DL,'0' 		
	JL NUM 			; IF < 0 PROCESS NEXT
	CMP DL,'9' 		
	JG NUM 			; IF > 9 PROCESS NEXT

VALID_NUM:
	INC BH 			; BH++
	PRINT DL  
	CMP BH,2 		; {1: NO MIN FOUND YET, 2: ONLY MIN 1 FOUND, 3: MIN 1,2 FOUND}
	JLE NUM 
	
	; CX HOLDS (MIN1,MIN2)

	CMP CL,DL   	; CURRENT <= MIN2
	JLE CHECK
	CMP CH,CL 		; MIN1 <= MIN2
    JLE CHECK2 

    MOV CH,CL   	; MIN1 := MIN2
	MOV CL,DL 		; MIN2 := CURRENT

	JMP NUM 		; PROCESS NEXT NUMBER

CHECK: 			; CURRENT >= MIN2
	CMP CH,DL   ; CURRENT <= MIN1?
	JLE NUM     ; PROCESS NEXT NUMBER
	CMP CL,DL   ; IS MIN2 == CURRENT
	JE NUM      ; PROCESS NEXT NUMBER
	MOV CH,CL   ; MIN1 := MIN2
	MOV CL,DL 	; MIN2 := CURRENT

	JMP NUM 	; PROCESS NEXT NUMBER

CHECK2:
	MOV CL,DL 	; MIN2 := CURRENT
	JMP NUM 	; PROCESS NEXT NUMBER

TELOS:
	PRINT_STR NEW_LINE 	; NEWLINE
	PRINT CH    		; MIN1
	PRINT CL    		; MIN2
	PRINT_STR NEW_LINE  ; NEWLINE
	
	JMP ENTRY 			; REPEAT	

QUIT:
	EXIT
MAIN ENDP

CODE ENDS
END MAIN

	
