PRINT_STR MACRO STRING
	PUSH DX
	PUSH AX
	LEA  DX,STRING
	MOV  AH,09H
	INT  21H
	POP  AX
	POP  DX
ENDM

EXIT MACRO
	MOV AH,4CH
	INT 21H
ENDM

PRINT MACRO CHAR
	PUSH DX
	PUSH AX
	MOV  DL,CHAR
	MOV  AH,02H
	INT  21H
	POP  AX
	POP  DX
ENDM

READ MACRO
	MOV AH,08H
	INT 21H
ENDM

DATA SEGMENT
	MSG DB 0AH,0DH,'GIVE UP TO 16 CHARACTERS: $'
	INPUT DB 16 DUP(?)
	NEW_LINE DB 0AH,0DH, '$'
ENDS

CODE SEGMENT
ASSUME CS:CODE,DS:DATA,SS:STACK

MAIN PROC FAR
	MOV AX,DATA
	MOV DS,AX

ENTRY:
	PRINT_STR MSG
    MOV  CX,10H     ; CX=16

INIT:               ; INITIALIZATION
	LEA  DI,INPUT 	; DI POINTS TO INPUT
	ADD  DI,CX 		; DI POINTS TO INPUT+16
	DEC  DI			; DI POINTS TO INPUT+15 (LAST MEM LOCATION)
	MOV  AL,00H
	MOV  [DI],AL 	; [DI] = 0
	LOOP INIT 		; [INPUT .. INPUT+15] = 0

CONTINUE:
	MOV CX,0 
	MOV BX,0
	MOV DX,0
	LEA DI,INPUT 	; DI POINTS TO INPUT

READ_NEXT:
	READ 			; READ ASCII CHAR INTO AL REGISTER
	CMP AL,0DH      ; ENTER PRESSED ? 
	JE  RESULT 		; IF YES THEN SHOW RESULT
	
	CMP AL,'*'      ; IF * TERMINATE
	JE  QUIT 
	
	CMP AL,20H      ; WHITESPACE
	JE  SAVE 		
	
	CMP AL,'0'      ; IF LESS THAN 0 (ASCII)
	JL  READ_NEXT 	; READ AGAIN
	CMP AL,39H 		; IF LESS THAN OR EQUAL TO '9'
	JLE SAVE_DIG 	; AL BETWEEN [30H .. 39H] (DIGITS)
	
	CMP AL,'A'      ; UPPERCASE
	JL  READ_NEXT 	; IF LESS THAN 41H READ AGAIN
	CMP AL,'Z' 		; IF LESS THAN OR EQUAL TO 5AH 
	JLE SAVE 		; SAVE UPPERCASE

	CMP AL,'a'      ; LOWERCASE
	JL  READ_NEXT 	; IF < 61H READ AGAIN
	CMP AL,'z' 		; IF > 7AH READ AGAIN
	JG  READ_NEXT  

SAVE:	     		; SAVE CHARACTERS
	PRINT AL
	MOV [DI],AL
	INC DI 			; MEMORY LOCATION INDEX
	INC BL     		; COUNTER
	CMP BL,16 		
	JL  READ_NEXT
	JMP WAIT1 		; IF >= 16 CHARS GIVEN WAIT FOR ENTER OR *

SAVE_DIG:     		; SAVE DIGITS
	PRINT AL
	MOV [DI],AL     ; SAVE CHARACTER IN INPUT BUFFER [DI]
	INC DI          ; INCREMENT MEMORY INDEX LOCATION
	CMP BH,0  		; MIN1
	JE  MIN1        ; BH == 0 => FIND MIN1
	CMP BH,1 		; MIN2
	JE  MIN2        ; BH == 1 => FIND MIN2
	JMP DIG_OUT 

MIN1:         
	MOV CH,AL 		; STORE MIN1 IN CH
	
MIN2:
	MOV CL,AL  		; STORE MIN2 IN CL
	PUSH CX 		; SAVE (MIN1,MIN2) IN STACK

DIG_OUT:
    INC BH          ; BH {0,1: MIN NOT FOUND, 2: MIN1 FOUND, 3+: MIN1,MIN2 FOUND}
    INC BL          ; CHAR COUNTER ++
	CMP BL,16   	; COUNTER < 16
	JL  READ_NEXT 	; CONTINUE READING    
	
	
WAIT1:       	; READ 16 CHARACTERS NO MORE SPACE
	READ 		; READ ASCII CHAR INTO AL REGISTER
	CMP AL,0DH 	; ENTER RECEIVED
	JE RESULT

	CMP AL,'*' 	; TERMINATION SIGNAL
	JE QUIT
	
	JMP WAIT1
	
RESULT:
    CMP BL,0
    JE  ENTRY
	PRINT_STR NEW_LINE 
	LEA DI,INPUT 	; POINT TO [INPUT]
	PUSH BX      	; SAVE TO STACK (MIN_STATUS, NUM_OF_CHARS)

UPPERCASE:			; BH:BL HOLDS NUMBER OF UPPERCASE LETTERS
    CMP BL,0 		; WHILE BL != 0 REPEAT
    JE  GROUP1 		; IF BL == 0 NEXT GROUP
    DEC BL 			; DECREMENT
	MOV DL,[DI] 	; LOAD MEMORY
	INC DI 			; NEXT MEMORY LOCATION
	
	CMP DL,'A' 		; WHILE DL NOT IN [0x65 .. 0x5A] 
	JL UPPERCASE 	; NEXT UPPERCASE
	CMP DL,'Z'
	JG UPPERCASE 	; NEXT UPPERCASE

VALID_UPPERCASE:
	PRINT DL 		
	JMP UPPERCASE 	; NEXT UPPERCASE
	
GROUP1:				; GROUP UPPERCASE HAS NO MORE MEMBERS
	POP BX 			; RESTORE (MIN_STATUS, NUM_OF_CHARS) FROM STACK
	PRINT '-' 		; NEXT GROUP: LOWERCASE
	LEA DI,INPUT
	
	PUSH BX         ; SAVE TO STACK (MIN_STATUS, NUM_OF_CHARS)
LOWERCASE:    		; PROCESS GROUP LOWERCASE
    CMP BL,0 
    JE GROUP2 		; GROUP LOWERCASE HAS NO MORE MEMBERS
    DEC BL 			; COUNTER--
	MOV DL,[DI]
	INC DI 			; NEXT MEMORY LOCATION
	
	CMP DL,'a' 		; IF [MEM] NOT IN [0x61 .. 0x7a]
	JL LOWERCASE 	; CHECK NEXT
	CMP DL,'z'
	JG LOWERCASE 	; CHECK NEXT IF LOWERCASE

VALID_LOWERCASE:
	PRINT DL 		; VALID LOWERCASE PRINT IT
	JMP LOWERCASE 	; PROCESS NEXT LOWERCASE

GROUP2:				; GROUP:LOWERCASE HAS NO MORE MEMBERS
	POP BX          ; RESTORE (MIN_STATUS, NUM_OF_CHARS) FROM STACK
	PRINT '-'

	LEA DI,INPUT 	; POINT TO START OF INPUT MEMORY LOCATION
	POP CX          ; RESTORE (MIN1,MIN2) FROM STACK
	MOV BH,0        ; MIN_STATUS=NOT_YET_FOUND (INIT)

NUM:           		; GROUP:NUMBERS
    CMP BL,0 		
    JE  PRINT_RES	; NOTHING TO PROCESS => EXIT
    DEC BL			; COUNTER--
	MOV DL,[DI] 	; LOAD MEMORY LOCATION
	INC DI 			; MEMORY INDEX LOCATION ++
	
	CMP DL,'0' 		; [30H .. 39H] == ASCII[0 .. 9]
	JL NUM 			; IF < 0 PROCESS NEXT
	CMP DL,'9' 		
	JG NUM 			; IF > 9 PROCESS NEXT

VALID_NUM:          ; NOT SKIPPED - THEREFORE DL HOLDS A VALID DIGIT
	INC BH 			; BH++
	PRINT DL        ; PRINT DIGIT
	CMP BH,2 		; {1: NO MIN FOUND YET, 2: ONLY MIN 1 FOUND, 3+: MIN 1,2 FOUND}
	JLE NUM 
	
	; CX HOLDS (MIN1,MIN2)
	CMP CL,DL   	; MIN2 <= CURRENT
	JLE CHECK       ; IF TRUE GOTO CHECK
	
	; AT THIS POINT # MIN2 > CURRENT #
	CMP CH,CL 		; IS MIN1 <= MIN2 ?
    JLE CHECK2      ; IF TRUE UPDATE MIN2 => (MIN2 := CURRENT)
                    
    ; AT THIS POINT # MIN1 > MIN2 && CURRENT < MIN2 #
    MOV CH,CL   	; MIN1 := MIN2
	MOV CL,DL 		; MIN2 := CURRENT

	JMP NUM 		; PROCESS NEXT NUMBER

CHECK: 			; # CURRENT >= MIN2 #
	CMP CH,DL   ; MIN1 <= CURRENT ?
	JLE NUM     ; IF TRUE THEN PROCESS NEXT NUMBER
	
	; # MIN1 > CURRENT #
	CMP CL,DL   ; IS MIN2 == CURRENT
	JE NUM      ; IF TRUE THEN PROCESS NEXT NUMBER
	
	; # MIN1 > CURRENT && MIN2 > CURRENT #
	MOV CH,CL   ; MIN1 := MIN2
	MOV CL,DL 	; MIN2 := CURRENT

	JMP NUM 	; PROCESS NEXT NUMBER

CHECK2:
	MOV CL,DL 	; MIN2 := CURRENT
	JMP NUM 	; PROCESS NEXT NUMBER

PRINT_RES:
	PRINT_STR NEW_LINE 	; NEWLINE
	PRINT CH    		; MIN1
	PRINT CL    		; MIN2
	PRINT_STR NEW_LINE  ; NEWLINE
	
	JMP ENTRY 			; REPEAT	

QUIT:
	EXIT    ; MACRO EXPANSION
MAIN ENDP

ENDS
END
